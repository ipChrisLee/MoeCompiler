#pragma once

#ifndef IGNORE_WHEN_TESTING

#include <string>
#include <string_view>
#include <any>

#include <cprt.hpp>
#include <common.hpp>
#include <antlr4-runtime.h>

#include "frontend/IRAddr.hpp"
#include "frontend/IRInstr.hpp"
#include "frontend/SysAntlr/SysYParser.h"
#include "frontend/SysAntlr/SysYBaseVisitor.h"
#include "frontend/SysAntlr/SysYVisitor.h"


namespace frontend {

/*  Visitor for AST generated by parser.
 * */
class ASTVisitor : public SysYBaseVisitor {
  protected:
	ircode::AddrPool addrPool;
	ircode::Scope * pScopeNow;
	enum class BType {
		Float, Int, Error
	};
	
	enum class FuncType {
		Void, Float, Int, Error
	};
	
	struct Info {
		/*  inGlobal: is visitor processing statements on global field.
		 *  isGlobal is true at first, and becomes false when enter `FuncDef`, and
		 *  becomes true after leaving `FuncDef`.
		 * */
		bool inGlobal;
		/*  btype: basic type of decl var.
		 *  Changed when visiting BType.
		 * */
		BType btype;
		/*  isConst: is decl var constant.
		 *  Changed just after visiting ConstDecl/VarDecl.
		 * */
		bool isConst;
		/*  visitingConst: is calculating static value from exp.
		 * */
		bool visitingConst;
		
		/*  shape of array declaring.
		 *  The first index is the length of visiting.
		 *  You should back up shape by yourself.
		 * */
		std::vector<int> shape;
		
		/*  Function type.
		 * */
		FuncType funcType;
		
		Info() : inGlobal(true), btype(BType::Error), isConst(false),
		         visitingConst(false), shape(), funcType(FuncType::Error) {
		}
	} info;
	
	static BType strToBType(const std::string & str) {
		if (str == "float") {
			return BType::Float;
		} else if (str == "int") {
			return BType::Int;
		} else {
			com::Throw("Unknown BType[" + str + "]!", CODEPOS);
		}
	}
	
	static FuncType strToFuncType(const std::string & str) {
		if (str == "float") {
			return FuncType::Float;
		} else if (str == "int") {
			return FuncType::Int;
		} else if (str == "void") {
			return FuncType::Void;
		} else {
			com::Throw("Unknown BType[" + str + "]!", CODEPOS);
		}
		
	}
	
	static std::unique_ptr<ircode::TypeInfo>
	bTypeToTypeInfoUPtr(const BType btype, const std::vector<int> & shape = { }) {
		if (shape.empty()) {
			switch (btype) {
				case BType::Float: {
					return std::make_unique<ircode::FloatType>();
				}
				case BType::Int: {
					return std::make_unique<ircode::IntType>();
				}
				default: {
					com::Throw("Error BType!", CODEPOS);
				}
			}
		} else {
			switch (btype) {
				case BType::Float: {
					return std::make_unique<ircode::FloatArrayType>(shape);
				}
				case BType::Int: {
					return std::make_unique<ircode::IntArrayType>(shape);
				}
				default: {
					com::Throw("Error BType!", CODEPOS);
				}
			}
		}
	}
	
	com::UnaryVariant<
		std::unique_ptr<ircode::StaticValue>,
		std::string,
		BType,
		std::vector<ircode::AddrPara>,
		ircode::AddrPara
	> retVal;
  
  
  public:
	ircode::IRInstrPool instrPool;
	
	ASTVisitor();
	
	/*  Visit children.
	 *  return:
	 *      `nullptr`
	 * */
	antlrcpp::Any visitChildren(antlr4::tree::ParseTree * node) override;
	
	/*  Just visit children.
	 *  return:
	 *      `nullptr`
	 * */
	antlrcpp::Any visitCompUnit(SysYParser::CompUnitContext * ctx) override;
	
	/*  Just visit children
	 *  return:
	 *      `nullptr`
	 * */
	antlrcpp::Any visitDecl(SysYParser::DeclContext * ctx) override;
	
	antlrcpp::Any visitConstDecl(SysYParser::ConstDeclContext * ctx) override;
	
	/*  Visit BType.
	 *  Change `info.btype` according to `ctx->getText()`.
	 * */
	antlrcpp::Any visitBType(SysYParser::BTypeContext * ctx) override;
	
	antlrcpp::Any visitConstDef(SysYParser::ConstDefContext * ctx) override;
	
	antlrcpp::Any visitScalarConstInitVal(
		SysYParser::ScalarConstInitValContext * ctx
	) override;
	
	antlrcpp::Any
	visitListConstInitVal(SysYParser::ListConstInitValContext * ctx) override;
	
	antlrcpp::Any visitVarDecl(SysYParser::VarDeclContext * ctx) override;
	
	antlrcpp::Any visitUninitVarDef(SysYParser::UninitVarDefContext * ctx) override;
	
	antlrcpp::Any visitInitVarDef(SysYParser::InitVarDefContext * ctx) override;
	
	antlrcpp::Any visitScalarInitVal(SysYParser::ScalarInitValContext * ctx) override;
	
	antlrcpp::Any visitListInitval(SysYParser::ListInitvalContext * ctx) override;
	
	antlrcpp::Any visitFuncDef(SysYParser::FuncDefContext * ctx) override;
	
	antlrcpp::Any visitFuncType(SysYParser::FuncTypeContext * ctx) override;
	
	antlrcpp::Any visitFuncFParams(SysYParser::FuncFParamsContext * ctx) override;
	
	antlrcpp::Any visitFuncFParam(SysYParser::FuncFParamContext * ctx) override;
	
	antlrcpp::Any visitBlock(SysYParser::BlockContext * ctx) override;
	
	antlrcpp::Any visitBlockItem(SysYParser::BlockItemContext * ctx) override;
	
	antlrcpp::Any visitAssignment(SysYParser::AssignmentContext * ctx) override;
	
	antlrcpp::Any visitExpStmt(SysYParser::ExpStmtContext * ctx) override;
	
	antlrcpp::Any visitBlockStmt(SysYParser::BlockStmtContext * ctx) override;
	
	antlrcpp::Any visitIfStmt1(SysYParser::IfStmt1Context * ctx) override;
	
	antlrcpp::Any visitIfStmt2(SysYParser::IfStmt2Context * ctx) override;
	
	antlrcpp::Any visitWhileStmt(SysYParser::WhileStmtContext * ctx) override;
	
	antlrcpp::Any visitBreakStmt(SysYParser::BreakStmtContext * ctx) override;
	
	antlrcpp::Any visitContinueStmt(SysYParser::ContinueStmtContext * ctx) override;
	
	antlrcpp::Any visitReturnStmt(SysYParser::ReturnStmtContext * ctx) override;
	
	antlrcpp::Any visitExp(SysYParser::ExpContext * ctx) override;
	
	antlrcpp::Any visitCond(SysYParser::CondContext * ctx) override;
	
	antlrcpp::Any visitLVal(SysYParser::LValContext * ctx) override;
	
	/**
	 * @returns Return instance is stored in @c this.retVal , the type of return instance:
	 * @returns <tt>std::unique_ptr\<ircode::StaticValue\></tt> .
	 */
	antlrcpp::Any visitNumber(SysYParser::NumberContext * ctx) override;
	
	antlrcpp::Any visitUnary1(SysYParser::Unary1Context * ctx) override;
	
	antlrcpp::Any visitUnary2(SysYParser::Unary2Context * ctx) override;
	
	antlrcpp::Any visitUnary3(SysYParser::Unary3Context * ctx) override;
	
	antlrcpp::Any visitUnaryOp(SysYParser::UnaryOpContext * ctx) override;
	
	antlrcpp::Any visitFuncRParams(SysYParser::FuncRParamsContext * ctx) override;
	
	antlrcpp::Any visitExpAsRParam(SysYParser::ExpAsRParamContext * ctx) override;
	
	antlrcpp::Any visitStringAsRParam(SysYParser::StringAsRParamContext * ctx) override;
	
	/**
	 * @For
	 *      @c visitPrimaryExp1 , @c visitPrimaryExp2 , @c visitPrimaryExp3 ,
	 *      @c visitMul2 , @c visitMul1 , @c visitAdd2 , @c visitAdd1
	 * @returns Return instance is stored in @c this.retVal , the type of return instance:
	 * @returns <tt>std::unique_ptr\<ircode::StaticValue\></tt> if @c info.visitingConst is @c true .
	 */
	antlrcpp::Any visitPrimaryExp1(SysYParser::PrimaryExp1Context * ctx) override;
	
	antlrcpp::Any visitPrimaryExp2(SysYParser::PrimaryExp2Context * ctx) override;
	
	antlrcpp::Any visitPrimaryExp3(SysYParser::PrimaryExp3Context * ctx) override;
	
	antlrcpp::Any visitMul2(SysYParser::Mul2Context * ctx) override;
	
	antlrcpp::Any visitMul1(SysYParser::Mul1Context * ctx) override;
	
	antlrcpp::Any visitAdd2(SysYParser::Add2Context * ctx) override;
	
	antlrcpp::Any visitAdd1(SysYParser::Add1Context * ctx) override;
	
	/*
	 * */
	antlrcpp::Any visitRel2(SysYParser::Rel2Context * ctx) override;
	
	antlrcpp::Any visitRel1(SysYParser::Rel1Context * ctx) override;
	
	antlrcpp::Any visitEq1(SysYParser::Eq1Context * ctx) override;
	
	antlrcpp::Any visitEq2(SysYParser::Eq2Context * ctx) override;
	
	antlrcpp::Any visitLAnd2(SysYParser::LAnd2Context * ctx) override;
	
	antlrcpp::Any visitLAnd1(SysYParser::LAnd1Context * ctx) override;
	
	antlrcpp::Any visitLOr1(SysYParser::LOr1Context * ctx) override;
	
	antlrcpp::Any visitLOr2(SysYParser::LOr2Context * ctx) override;
	
	//  Just visit AddExp.
	antlrcpp::Any visitConstExp(SysYParser::ConstExpContext * ctx) override;
};

}

#endif